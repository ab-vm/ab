#ifndef AB_XEXPRDISASM_HPP_
#define AB_XEXPRDISASM_HPP_

///
/// Disassembling and code-to-text conversion of expressions.
///

#include <Ab/XExpr.hpp>
#include <Ab/XOpCode.hpp>

#include <fmt/format.h>
#include <fmt/format.h>
#include <string_view>

namespace Ab {

constexpr const char* cstring(XOpCode code) {
	switch(code) {
	@[ for operator in data.abx_operators ]
		case XOpCode::@( operator.name | constify ):
			return XOPCODE_NAME<XOpCode::@( operator.name | constify )>;
	@[ endfor ]
	default:
		return "unknown";
	}
}

constexpr std::string_view name(XOpCode code) {
	return std::string_view(cstring(code));
}

inline std::ostream& operator<<(std::ostream& out, const XOpCode& code) {
	return out << cstring(code);
}

}  // namespace Ab

template <>
struct fmt::formatter<Ab::XOpCode> : fmt::formatter<const char*> {
	template <typename FormatContext>
	constexpr auto format(const Ab::XOpCode& code, FormatContext& cx) {
		return formatter<const char*>::format(Ab::cstring(code), cx);
	}
};

struct BaseXExprFormatter {
	template <typename ParseContext>
	constexpr auto parse(ParseContext& cx) { return cx.begin(); }
};

@[ for operator in data.abx_operators ]

	@[ set expr_typename = ("x_expr_" + operator.name) | typeify ]

	template <>
	struct fmt::formatter<Ab::@( expr_typename )> : BaseXExprFormatter {
		template <typename FormatContext>
		constexpr auto format(const Ab::@( expr_typename )& expr, FormatContext& cx) {
			return format_to(
				cx.out(),
				"(@( operator.name )@[ for imm in operator.immediates ] :@( imm.name ) {}@[ endfor ])"
				@[ for imm in operator.immediates ]
					, expr.@( imm.name | varify )
				@[ endfor ]
			);
		}
	};

	inline std::ostream& operator<<(std::ostream& out, const Ab::@( expr_typename )& expr) {
		return out << fmt::format("{}", expr);
	}

@[ endfor ]

#endif  // AB_XEXPRDISASM_HPP_
