#ifndef AB_INTERPRETER_HPP_
#define AB_INTERPRETER_HPP_

#include <Ab/Config.hpp>
#include <Ab/Address.hpp>
#include <Ab/Assert.hpp>
#include <Ab/Bytes.hpp>
#include <Ab/Func.hpp>
#include <iostream>

namespace Ab {

/// Handle to stack memory.
///
class Stack {
public:
	/// Default stack size.
	///
	static constexpr std::size_t DEFAULT_SIZE = kibibytes(8);

	Stack(std::size_t size) noexcept {
		address_ = new(std::nothrow) Byte[size];
		AB_ASSERT(address_ != nullptr);
	}

	Stack(const Stack&) = delete;

	Stack(Stack&& other) {
		address_ = other.address_;
		other.address_ = nullptr;
	}

	Stack() : Stack(DEFAULT_SIZE) {}

	~Stack() noexcept {
		if (address_ != nullptr) {
			delete[] address_;
		}
	}

	Byte* address() noexcept { return address_; }

	const Byte* address() const noexcept { return address_; }

	Stack& operator=(const Stack&) = delete;

private:
	Byte* address_;
};

/// Special 1-word struct embedded in the interpreter frame.
///
class FrameFlags {
public:
	constexpr FrameFlags() noexcept : value_(0) {}

	constexpr FrameFlags(const FrameFlags&) noexcept = default;

	constexpr std::uintptr_t value() const noexcept { return value_; }

private:
	std::uintptr_t value_;
};

/// Storage for saved-state embedded in the interpreter frame.
///
struct FrameSaveArea {
	Address pc;  ///< Saved instruction pointer.
	Address fp;  ///< Saved frame pointer.
	Address cp;  ///< Saved Constants/literals pointer/
};

/// Generic frame.
///
struct Frame {
	FrameFlags flags;
	FrameSaveArea save_area;
};

/// Call-in / toplevel frame.
///
struct EntryFrame {
	FrameFlags flags;
	FrameSaveArea save_area;
};

union AnyFrame {
	Frame as_frame;
	EntryFrame as_entry_frame;
};

enum class ValueKind {
	@[for entry in data.types]
		@(entry | upper)@(",\n" if not loop.last -)
	@[endfor]
};

union AnyValue {
	@[for key in data.types]
		@(data.types[key].ctype) @("as_" + key | varify);
	@[endfor]
};

enum class ExecCond { UNDEFINED, RUNNING, HALTED, TRAPPED, ERRORED };

enum class ExecAction { EXIT = 0, INTERPRET = 1, HALT = 2, CRASH = 3 };

/// Flags are runtime conditions located in secondary state.
///
struct Flags {
	@[for flag in data.interpreter_state.flags]
		@(flag.type) @(flag.name | varify);
	@[endfor]
};

/// Primary state is cached in the interpreter, and kept in registers if possible.
/// The state is only reflected back into the struct explicitly, when needed.
///
struct ExecStateA {
	@[for state in data.interpreter_state.primary]
		@(state.type) @(state.name | varify);
	@[endfor]
};

/// Secondary state is kept in memory and up-to-date. Frequently accessed data
/// should be placed in the primary state and cached in registers during execution.
/// Infrequently accessed state can be stored here.
///
struct ExecStateB {
	@[for state in data.interpreter_state.secondary]
		@(state.type) @(state.name | varify);
	@[endfor]
};

/// Interpreter state is divided into primary and secondary state.
/// primary state is frequently accessed, and typically cached in local registers.
/// Secondary state is less frequently accessed, and normally kept up to date in memory.
///
struct ExecState {
	ExecStateA st_a;  ///< primary execution state.
	ExecStateB st_b;  ///< secondary execution state.
};

/// Blow away the execution state.
///
inline void clear(ExecState* state) {
	state->st_b.stack       = nullptr;
	state->st_b.function    = nullptr;
	state->st_b.flags.trap  = false;
	state->st_b.flags.error = false;
	state->st_b.condition   = ExecCond::HALTED;

	state->st_a.fp = state->st_b.stack;
	state->st_a.pc = nullptr;
}

class Interpreter;

using PrimitiveFn = void (*)(ExecState*);

void interpret(ExecState* state, Func* function);

class Interpreter {
public:
	Interpreter();

	Interpreter(const Interpreter&) = delete;

	Interpreter(Interpreter&&) = default;

	~Interpreter();

	ExecState& exec_state() noexcept { return state_; }

	const ExecState& exec_state() const noexcept { return state_; }

	/// initialize interpreter state and execute interpreter.
	///
	void interpret(const Func* target);

	/// Read from the result register.
	///
	AnyValue result() const noexcept { return state_.st_a.result; }

	/// Read a u32 from the result register.
	///
	std::uint32_t result_u32() const {
		return state_.st_a.result.as_u32;
	}

private:
	ExecState state_;
	Stack stack_;
};

}  // namespace Ab

#endif  // AB_INTERPRETER_HPP_
