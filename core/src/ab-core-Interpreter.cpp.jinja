#define AB_DEBUG

#include <Ab/Context.hpp>
#include <Ab/Debug.hpp>
#include <Ab/Interpreter.hpp>
#include <Ab/Module.hpp>
#include <Ab/Opcode.hpp>
#include <Ab/VirtualMachine.hpp>

#include <cstdio>

namespace Ab {

/*
 * Call-in Layout
 *
 * high address (grows down)
 *
 * Value                             | Address         | Notes
 * ----------------------------------|-----------------|--------------------------------------------
 * - frame                           |                 | frame end
 *   - caller state                  |                 | Pushed despite 
 *     - pc                          |                 |
 *     - fp                          |                 |
 *     - cp                          |                 |
 *   - flags                         | sp[nvar + narg] | tagged as native frame
 * - registers                       |                 |
 *   - variables                     |                 |
 *     - var 2                       | sp[narg + 2]    |
 *     - var 1                       | sp[narg + 1]    |
 *     - var 0                       | sp[narg + 0]    |
 *   - arguments                     |                 | args assigned directly by call-in native
 *     - arg 2                       | sp[2]           |
 *     - arg 1                       | sp[1]           |
 *     - arg 0                       | sp[0]           | register pointer
 *
 * low address (grows down)
 * 
 * In a native call-in, the arguments are written directly in-place by the caller, and the return
 * values will be manually copied out. Thus, the call-in has no register slots in it's frame.
 */

/*
 * high address (grows down)
 *
 * Value                             | Address         | Notes
 * ----------------------------------|-----------------|--------------------------------------------
 * - stack-end eye catcher           | entry Frame
 * - registers                       |
 *   - variables (results)           | vars are for results only -- no args
 *     - var 2                       | return value 2
 *     - var 1                       | return value 1
 *     - var 0                       | return value 0
 * - frame                           |
 *   - flags <end>                   |
 * - frame                           | rp + register-end + frame-size     <----- frame end
 *   - caller state                  |
 *     - pc                          |
 *     - fp                          |
 *     - cp                          |
 *   - flags <normal>                | rp[nregs] = rp + nregs * 4         <----- register end
 * - registers                       |
 *   - variables                     |
 *     - var 2                       | rp[5] = rp + 20
 *     - var 1                       | rp[4] = rp + 16
 *     - var 0                       | rp[3] = rp + 12
 *   - arguments                     |
 *     - arg 2                       | rp[2] = rp +  8
 *     - arg 1                       | rp[1] = rp +  4
 *     - arg 0                       | rp[0] = rp +  0                    <----- register pointer
 * - frame                           |
 *
 * low address (grows down)
 */

@#  State Declarations, Commit and Reload #

@[set decl_state_vars]
	@[for var in data.interpreter_state.primary]
		@(- var.type) @(var.name);
	@[endfor]
@[endset]

@[set commit_state]
	// commit state
	@[for var in data.interpreter_state.primary]
		state->st_a.@(var.name) = @(var.name);
	@[endfor]
@[endset]

@[set reload_state]
	// reload_state
	@[for var in data.interpreter_state.primary]
		@(var.name) = state->st_a.@(var.name);
	@[endfor]
@[endset]

@# Helpers for implementing bytecode handlers #

@[macro trace(name)]
	fprintf(stderr, "executing: pc=%p op=%d name=@(name)\n", pc, (int)*pc);
@[endmacro]

@# mangle an operator name to the handlers name #
@[macro handler_name(op_name)]
	@(("do_" + op_name) | varify)
@[endmacro]

@[macro begin_handler(op_name)]

@[endmacro]

@[macro handle(op_name)]
	@(handler_name(op_name)): {
		@(trace(op_name))
		@(caller())
	}
@[endmacro]

@[set dispatch]
	// dispatch
	fprintf(stderr, "dispatch: pc=%p op=%d\n", pc, (int)*pc);
	goto *INSTRUCTION_TABLE[*pc];
@[endset]

@# Register Access #

@[macro reg(type, index)]
	*(@(type)*)(fp + (@(index)*SIZEOF_SLOT))
@[endmacro]

@[macro get_reg(type, index)]
	*(@(type)*)(fp + (@(index)*SIZEOF_SLOT))
@[endmacro]

@[macro set_reg(type, index, value)]
	*((@(type))(fp + (@(index)*SIZEOF_SLOT)) = @(value);
@[endmacro]

@# Instruction Decoding #

@[macro imm(type, offset)]
	*(const @(type)*)(pc + @(offset))
@[endmacro]

#define REG_PTR(idx) (fp + ((idx)*SIZEOF_SLOT))

#define I32_REG_PTR(idx) ((std::uint32_t*)REG_PTR(idx))
#define I64_REG_PTR(idx) ((std::uint64_t*)REG_PTR(idx))
#define F32_REG_PTR(idx) ((float*)REG_PTR(idx))
#define F64_REG_PTR(idx) ((double*)REG_PTR(idx))

#define REG(idx) (*REG_PTR(idx))

#define I32_REG(idx) (*I32_REG_PTR(idx))
#define I64_REG(idx) (*I64_REG_PTR(idx))
#define F32_REG(idx) (*F32_REG_PTR(idx))
#define F64_REG(idx) (*F64_REG_PTR(idx))

///
/// Forward Declarations
///

static Byte* act(ExecState* state, ExecAction action);

static std::pair<ExecAction, Byte*> do_interpret(ExecState* state);

///
/// Interpreter method calls
///

Interpreter::Interpreter() {
	std::size_t stack_size = 2048;

	state_.st_b.stack = new Byte[stack_size];
	state_.st_b.func = nullptr;
	state_.st_b.flags.trap = false;
	state_.st_b.flags.error = false;
	state_.st_b.condition = ExecCond::HALTED;

	state_.st_a.fp = state_.st_b.stack + stack_size;
	state_.st_a.pc = nullptr;
	state_.st_a.cp = nullptr;
}

Interpreter::~Interpreter() {
	delete[] state_.st_b.stack;
}

///
/// Call frame helpers
///

template <typename T, typename... Args>
T* push_value(Byte*& stack, Args&&... args) {
	static_assert(std::is_trivially_destructible_v<T>);
	stack -= sizeof(T);
	return new(stack) T(std::forward<Args>(args)...);
}

template <typename T, typename... Args>
T* push_value(ExecState& state, Args&&... args) {
	return push(state.st_a.fp, std::forward<Args>(args)...);
}

template <typename T, typename... Args>
T* push_value(Context& cx, Args&&... args) {
	return push(cx.exec_state(), std::forward<Args>(args)...);
}

template <typename T>
T* pop_value(Byte*& stack) {
	auto r = reinterpret_cast<T*>(stack);
	static_assert(std::is_trivially_destructible_v<T>);
	stack += sizeof(T);
	return r;
}

template <typename T>
T* pop_value(ExecState& state) {
	pop<T>(state.st_a.fp);
}

template <typename T>
void pop_value(Context& cx) {
	pop<T>(cx.exec_state());
}

Byte* push_regs(Byte*& stack, std::size_t nregs) {
	stack -= nregs * SIZEOF_SLOT;
	return stack;
}

Byte* push_regs(ExecState& state, std::size_t nregs) {
	return push_regs(state.st_a.fp, nregs);
}

Byte* push_regs(Context& cx, std::size_t nregs) {
	return push_regs(cx.exec_state(), nregs);
}

Byte* pop_regs(Byte*& stack, std::size_t nregs) {
	auto copy = stack;
	stack += nregs * SIZEOF_SLOT;
	return copy;
}

Byte* pop_regs(ExecState& state, std::size_t nregs) {
	return pop_regs(state.st_a.fp, nregs);
}

Byte* pop_regs(Context& cx, std::size_t nregs) {
	return pop_regs(cx.exec_state(), nregs);
}

template <typename T>
T* peek_value(Byte* stack, std::size_t offset = 0) {
	return reinterpret_cast<T*>(stack + offset);
}

///
/// Public API: calling into the interpreter
///

Byte* enter_native_frame(Context& cx, std::size_t nregs) {
	ExecState& state = cx.exec_state();
	Byte* stack = state.st_a.fp;

#ifdef AB_DEBUG
	push_value<std::uint64_t>(stack, 0xdeadbeef);
#endif 

	NativeFrame* frame = push_value<NativeFrame>(stack);
	AB_DBG_MSG("frame @{}\n", (void*)frame);
	frame->save_area.fp = state.st_a.fp;
	frame->save_area.pc = state.st_a.pc;
	frame->save_area.cp = state.st_a.cp;

	push_regs(stack, nregs);

	state.st_a.fp = stack;

	AB_DBG_MSG("enter_native_frame: stack={}\n", (void*)stack);

	return stack;
}

Byte* leave_native_frame(Context& cx, std::size_t nregs) {
	ExecState& state = cx.exec_state();
	Byte* stack = state.st_a.fp;

	pop_regs(stack, nregs);
	auto* frame = pop_value<NativeFrame>(stack);

	state.st_a.cp = frame->save_area.cp;
	state.st_a.pc = frame->save_area.pc;
	state.st_a.fp = frame->save_area.fp;

#ifdef AB_DEBUG
	auto* eyecatcher = pop_value<std::uint64_t>(stack);
	AB_ASSERT(*eyecatcher == 0xdeadbeef);
#endif

	return state.st_a.fp;
}

static Byte* interpret_func(ExecState* state, FuncInst* func) {
	state->st_b.func = func;
	state->st_a.pc = func->body();
	state->st_a.cp = nullptr; // TODO: func->constants();
	return act(state, ExecAction::INTERPRET);
}

static Byte* interpret_func(Context& cx, FuncInst* func) {
	return interpret_func(&cx.exec_state(), func);
}

Byte* enter_interpreter(Context& cx, FuncInst* func_inst) {
	return interpret_func(cx, func_inst);
}

void interpret(ExecState* state, FuncInst* func) {
	interpret_func(state, func);
}

void interpret(ExecState* state, ModuleInst* mod, std::size_t index) {
	interpret_func(state, mod->func_inst(index));
}

///
/// Interpreter Action Handling
///

#define DO_ACTION(action) goto *ACTION_TABLE[std::size_t(action)]

/// The main interpreter action trampoline.
///
static Byte* act(ExecState* state, ExecAction action) {
	constexpr static void* const ACTION_TABLE[4] = {
		&&do_crash,     // 0
		&&do_interpret, // 1
		&&do_halt,      // 2
		&&do_exit       // 3
	};

	Byte* ret = nullptr;

	AB_DBG_MSG("enter action loop\n");
	DO_ACTION(action);

do_exit:
	AB_DBG_MSG("action: exit\n");
	return ret;

do_interpret:
	AB_DBG_MSG("action: interpret\n");
	std::tie(action, ret) = do_interpret(state);
	DO_ACTION(action);

do_halt:
	AB_DBG_MSG("action: halt\n");
	return nullptr;

do_crash:
	AB_DBG_MSG("action: crash\n");
	AB_ASSERT_UNREACHABLE();
}

///
/// Core Bytecode Interpreter
///

static std::pair<ExecAction, Byte*> do_interpret(ExecState* state) {

	static void* const INSTRUCTION_TABLE[256] = {
		@[for i in range(0, 256)-]
			@[- set operators = data.abx_operators | selectattr('code', 'equalto', i) | list]
			@[- if operators | count != 0]
				@[- set operator = operators[0] -]
				&&@(handler_name(operator.name))
			@[- else -]
				&&do_unimplemented
			@[-endif]@("," if not loop.last) // @(i)
		@[endfor]
	};

	@(decl_state_vars)
	@(reload_state)
	@(dispatch)

	///////////// Special Handlers

	@[call handle('unimplemented')]
		@(commit_state)
		AB_ASSERT_UNREACHABLE();
	@[endcall]

	@[call handle('unreachable')]
		@(commit_state)
		state->st_b.flags.error = true;
		return {ExecAction::EXIT, nullptr};
	@[endcall]

	@[call handle('nop')]
		pc += NOP_SIZE;
		@(dispatch)
	@[endcall]

	@[call handle('halt')]
		@(commit_state)
		return {ExecAction::HALT, nullptr};
	@[endcall]

	@[call handle('call_primitive')]
		@(commit_state)
		auto target = @(imm('void*', 'CALL_PRIMITIVE_IMM_TGT'));
		// TODO: target(state);
		@(reload_state)
		pc += CALL_PRIMITIVE_SIZE;
		@(dispatch)
	@[endcall]

	@[call handle('goto')]
		auto off = @(imm('std::uint32_t', 'GOTO_IMM_OFF'));
		fprintf(stderr, "offset=%d\n", off);
		pc += off + GOTO_SIZE;
		@(dispatch)
	@[endcall]

	@[call handle('goto_if')]
		auto reg = @(imm('std::int32_t',  'GOTO_IF_IMM_TST'));
		auto off = @(imm('std::uint32_t', 'GOTO_IF_IMM_OFF'));
		auto tst = @(reg('std::uint32_t', 'reg'));
		pc += GOTO_IF_SIZE;
		if (tst) {
			pc += off;
		}
		@(dispatch)
	@[endcall]

	@[call handle('goto_unless')]
		auto reg = @(imm('std::uint32_t', 'GOTO_UNLESS_IMM_TST'));
		auto off = @(imm('std::int32_t',  'GOTO_UNLESS_IMM_OFF'));
		auto tst = @(reg('std::uint32_t', 'reg'));
		fprintf(stderr, "offset=%d\n", off);
		pc += GOTO_UNLESS_SIZE;
		if (!tst) {
			pc += off;
		}
		@(dispatch)
	@[endcall]

	@[call handle('return')]
		FuncInst* func = state->st_b.func;
		const FrameTag* tag = reinterpret_cast<FrameTag*>(fp + func->nreg_bytes());
	
		if (tag->frame_kind() == FrameKind::NATIVE) {
			@(commit_state)
			return {ExecAction::EXIT, nullptr};
		}

		@(commit_state)
		AB_ASSERT_UNREACHABLE();
	@[endcall]

	@[call handle('x32.return')]
		auto reg_ptr = REG_PTR(@(imm('std::uint32_t', 'X32_RETURN_IMM_SRC')));
		FuncInst* func = state->st_b.func;
		const FrameTag* tag = reinterpret_cast<FrameTag*>(fp + func->nreg_bytes());
	
		AB_DBG_MSG("reg_ptr={}\n", (void*)reg_ptr);
		AB_DBG_MSG("val={}\n", *(std::uint32_t*)reg_ptr);

		if (tag->frame_kind() == FrameKind::NATIVE) {
			@(commit_state)
			return {ExecAction::EXIT, reg_ptr};
		}

		@(commit_state)
		AB_ASSERT_UNREACHABLE();
	@[endcall]

	@[call handle('x64.return')]
		@(commit_state)
		AB_ASSERT_UNREACHABLE();
	@[endcall]

	@[call handle('call')]
		pc += CALL_SIZE;
		@(commit_state)
		return {ExecAction::CRASH, nullptr};
	@[endcall]

	@[call handle('call_indirect')]
		pc += CALL_INDIRECT_SIZE;
		return {ExecAction::CRASH, nullptr};
	@[endcall]

	@[call handle('get_global')]
		// TODO
		pc += GET_GLOBAL_SIZE;
		@(dispatch)
	@[endcall]

	@[call handle('set_global')]
		// TODO
		pc += SET_GLOBAL_SIZE;
		@(dispatch)
	@[endcall]

	@[call handle('move_x32')]
		auto dst = @(imm('std::uint32_t', 'MOVE_X32_IMM_DST'));
		auto src = @(imm('std::uint32_t', 'MOVE_X32_IMM_SRC'));

		@(reg('std::uint32_t', 'dst')) = @(reg('std::uint32_t', 'src'));
		pc += MOVE_X32_SIZE;
		@(dispatch)
	@[endcall]

	@[call handle('move_x64')]
		auto dst = @(imm('std::uint32_t', 'MOVE_X32_IMM_DST'));
		auto src = @(imm('std::uint32_t', 'MOVE_X32_IMM_SRC'));

		@(reg('std::uint64_t', 'dst')) = @(reg('std::uint64_t', 'src'));
		pc += MOVE_X64_SIZE;
		@(dispatch)
	@[endcall]

	@[call handle('load_result_x32')]
		auto dst = @(imm('std::uint32_t', 'LOAD_RESULT_X32_IMM_DST'));
		@(reg('std::uint32_t', 'dst')) = result.as_x32;
	@[endcall]

	@[call handle('load_result_x64')]
		auto dst = @(imm('std::uint64_t', 'LOAD_RESULT_X64_IMM_DST'));
		@(reg('std::uint64_t', 'dst')) = result.as_x32;
	@[endcall]

#if 0
	@(begin_handler("x32_get_arg")) {
		const auto expr = decode<XExprX32GetArg>(pc);
		push<std::uint32_t>(sp, localAt<std::uint32_t>(bp, expr.offset));
		pc += XEXPR_X32_GET_LOCAL_SIZE;
		@(dispatch)
	}

	@(begin_handler("x32_set_loca")) {
		const auto expr = decode<XExprX32SetLocal>(pc);
		localAt<std::uint32_t>(bp, expr.offset) = pop<std::uint32_t>(sp);
		pc += XEXPR_X32_SET_LOCAL_SIZE;
		@(dispatch)
	}

	@(begin_handler("x32_tee_local")) {
		const auto expr = decode<XExprX32TeeLocal>(pc);
		localAt<std::uint32_t>(bp, expr.offset) = peek<std::uint32_t>(sp);
		pc += XEXPR_X32_TEE_LOCAL_SIZE;
		@(dispatch)
	}

	@(begin_handler("x64_get_local")) {
		const auto expr = decode<XExprX64GetLocal>(pc);
		push<std::uint64_t>(sp, localAt<std::uint64_t>(bp, expr.offset));
		pc += XEXPR_X64_GET_LOCAL_SIZE;
		@(dispatch)
	}

	@(begin_handler("x64_set_local")) {
		const auto expr = decode<XExprX64SetLocal>(pc);
		localAt<std::uint64_t>(bp, expr.offset) = pop<std::uint64_t>(sp);
		pc += XEXPR_X64_SET_LOCAL_SIZE;
		@(dispatch)
	}

	@(begin_handler("x64_tee_local")) {
		const auto expr = decode<XExprX64TeeLocal>(pc);
		localAt<std::uint64_t>(bp, expr.offset) = peek<std::uint64_t>(sp);
		pc += XEXPR_X64_TEE_LOCAL_SIZE;
		@(dispatch)
	}

	@(begin_handler('get_global')) {
		@(commit_state)
		state.st_b.flags.error = true;
		return;
	}

	@(begin_handler('set_global')) {
		@(commit_state)
		state.st_b.flags.error = true;
		return;
	}

	@(begin_handler('i32_const')) {
		const auto& expr = *reinterpret_cast<const XExprI32Const*>(pc);
		push<std::int32_t>(sp, expr.value);
		pc += XEXPR_I32_CONST_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_const')) {
		const auto& expr = *reinterpret_cast<const XExprI32Const*>(pc);
		push<std::int32_t>(sp, expr.value);
		pc += XEXPR_I64_CONST_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_eqz')) {
		const auto x = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, x == 0);
		pc += XOpI32Eqz::SIZEOF;
		@(dispatch)
	}

	@(begin_handler('i32_eq')) {
		const auto rhs = pop<std::uint32_t>(sp);
		const auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs == rhs);
		pc += XEXPR_I32_EQ_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_ne')) {
		const auto rhs = pop<std::uint32_t>(sp);
		const auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs != rhs);
		pc += XEXPR_I32_NE_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_lt_s')) {
		const auto rhs = pop<std::int32_t>(sp);
		const auto lhs = pop<std::int32_t>(sp);
		push<std::uint32_t>(sp, lhs < rhs);
		pc += XEXPR_I32_LT_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_lt_u')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs < rhs);
		pc += XEXPR_I32_LT_U_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_gt_s')) {
		const auto rhs = pop<std::int32_t>(sp);
		const auto lhs = pop<std::int32_t>(sp);
		push<std::uint32_t>(sp, lhs > rhs);
		pc += XEXPR_I32_GT_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_gt_u')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs > rhs);
		pc += XEXPR_I32_GT_U_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_le_s')) {
		const auto rhs = pop<std::int32_t>(sp);
		const auto lhs = pop<std::int32_t>(sp);
		push<std::uint32_t>(sp, lhs <= rhs);
		pc += XEXPR_I32_LE_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_le_u')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs <= rhs);
		pc += XEXPR_I32_LE_U_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_ge_s')) {
		const auto rhs = pop<std::int32_t>(sp);
		const auto lhs = pop<std::int32_t>(sp);
		push<std::uint32_t>(sp, lhs >= rhs);
		pc += XEXPR_I32_GE_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_ge_u')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs >= rhs);
		pc += XEXPR_I32_GE_U_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_eqz')) {
		const auto x = pop<std::uint64_t>(sp);
		push<std::uint64_t>(sp, x == 0);
		pc += XEXPR_I64_EQZ_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_eq')) {
		const auto rhs = pop<std::uint64_t>(sp);
		const auto lhs = pop<std::uint64_t>(sp);
		push<std::uint64_t>(sp, lhs == rhs);
		pc += XEXPR_I64_EQ_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_ne')) {
		const auto rhs = pop<std::uint64_t>(sp);
		const auto lhs = pop<std::uint64_t>(sp);
		push<std::uint64_t>(sp, lhs != rhs);
		pc += XEXPR_I64_NE_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_lt_s')) {
		const auto rhs = pop<std::int64_t>(sp);
		const auto lhs = pop<std::int64_t>(sp);
		push<std::uint64_t>(sp, lhs < rhs);
		pc += XEXPR_I64_LT_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_lt_u')) {
		auto rhs = pop<std::uint64_t>(sp);
		auto lhs = pop<std::uint64_t>(sp);
		push<std::uint64_t>(sp, lhs < rhs);
		pc += XEXPR_I64_LT_U_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_gt_s')) {
		const auto rhs = pop<std::int64_t>(sp);
		const auto lhs = pop<std::int64_t>(sp);
		push<std::uint64_t>(sp, lhs > rhs);
		pc += XEXPR_I64_GT_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_gt_u')) {
		auto rhs = pop<std::uint64_t>(sp);
		auto lhs = pop<std::uint64_t>(sp);
		push<std::uint64_t>(sp, lhs > rhs);
		pc += XEXPR_I64_GT_U_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_le_s')) {
		const auto rhs = pop<std::int64_t>(sp);
		const auto lhs = pop<std::int64_t>(sp);
		push<std::uint64_t>(sp, lhs <= rhs);
		pc += XEXPR_I64_LE_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_le_u')) {
		auto rhs = pop<std::uint64_t>(sp);
		auto lhs = pop<std::uint64_t>(sp);
		push<std::uint64_t>(sp, lhs <= rhs);
		pc += XEXPR_I64_LE_U_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_ge_s')) {
		const auto rhs = pop<std::int64_t>(sp);
		const auto lhs = pop<std::int64_t>(sp);
		push<std::uint64_t>(sp, lhs >= rhs);
		pc += XEXPR_I64_GE_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i64_ge_u')) {
		auto rhs = pop<std::uint64_t>(sp);
		auto lhs = pop<std::uint64_t>(sp);
		push<std::uint64_t>(sp, lhs >= rhs);
		pc += XEXPR_I64_GE_U_SIZE;
		@(dispatch)
	}

#endif /////////////////////////////////////////////////////////////////////////

	@[call handle('i32.add')]
		auto dst_reg = @(imm('std::uint32_t', 'I32_ADD_IMM_DST'));
		auto lhs_reg = @(imm('std::uint32_t', 'I32_ADD_IMM_LHS'));
		auto rhs_reg = @(imm('std::uint32_t', 'I32_ADD_IMM_RHS'));

		auto dst_ptr = I32_REG_PTR(dst_reg); // @(reg('std::uint32_t', 'dst_reg'));
		auto lhs_ptr = I32_REG_PTR(lhs_reg); // @(reg('std::uint32_t', 'lhs_reg'));
		auto rhs_ptr = I32_REG_PTR(rhs_reg); // @(reg('std::uint32_t', 'rhs_reg'));

		auto lhs_val = *lhs_ptr;
		auto rhs_val = *rhs_ptr;
		auto dst_val = lhs_val + rhs_val;

		AB_DBG_MSG("  rhs reg={} ptr={} val={}\n", rhs_reg, (void*)rhs_ptr, rhs_val);
		AB_DBG_MSG("  lhs reg={} ptr={} val={}\n", lhs_reg, (void*)lhs_ptr, lhs_val);
		AB_DBG_MSG("  dst reg={} ptr={} val={}\n", dst_reg, (void*)dst_ptr, dst_val);

		*dst_ptr = dst_val;

		pc += I32_ADD_SIZE;
		@(dispatch)
	@[endcall]

#if 0 //////////////////////////////////////////////////////////////////////////

	@(begin_handler('i32_sub')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs - rhs);
		pc += XEXPR_I32_SUB_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_mul')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs * rhs);
		pc += XEXPR_I32_MUL_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_div_s')) {
		auto rhs = pop<std::int32_t>(sp);
		auto lhs = pop<std::int32_t>(sp);
		push<std::int32_t>(sp, lhs / rhs);
		pc += XEXPR_I32_DIV_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_div_u')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs / rhs);
		pc += XEXPR_I32_DIV_U_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_rem_s')) {
		auto rhs = pop<std::int32_t>(sp);
		auto lhs = pop<std::int32_t>(sp);
		push<std::int32_t>(sp, lhs % rhs);
		pc += XEXPR_I32_REM_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_rem_u')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs % rhs);
		pc += XEXPR_I32_REM_U_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_and')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs & rhs);
		pc += XEXPR_I32_AND_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_or')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs | rhs);
		pc += XEXPR_I32_OR_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_xor')) {
		auto rhs = pop<std::uint32_t>(sp);
		auto lhs = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, lhs ^ rhs);
		pc += XEXPR_I32_XOR_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_shl')) {
		auto shift = pop<std::uint32_t>(sp) % 32;
		auto value = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, value << shift);
		pc += XEXPR_I32_SHL_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_shr_s')) {
		auto shift = pop<std::uint32_t>(sp) % 32;
		auto value = pop<std::int32_t>(sp);
		push<std::uint32_t>(sp, value >> shift);
		pc += XEXPR_I32_SHR_S_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_shr_u')) {
		auto shift = pop<std::uint32_t>(sp) % 32;
		auto value = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, value >> shift);
		pc += XEXPR_I32_SHR_U_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_rotl')) {
		auto shift = pop<std::uint32_t>(sp) % 32;
		auto value = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, (value << shift) | (shift >> (32 - value))); 
		pc += XEXPR_I32_ROTL_SIZE;
		@(dispatch)
	}

	@(begin_handler('i32_rotr')) {
		auto shift = pop<std::uint32_t>(sp) % 32;
		auto value = pop<std::uint32_t>(sp);
		push<std::uint32_t>(sp, (value >> shift) | (shift << (32 - value)));
		pc += XEXPR_I32_ROTR_SIZE;
		@(dispatch)
	}
#endif

	AB_ASSERT_UNREACHABLE();
};

// std::int32_t Interpreter::interpret_i32(const Func* target) {
// 	interpret(target);
// 	return pop<std::int32_t>(state.st_a.sp);
// }

// void Interpreter::interpret_nil(const Func* target) {
// 	interpret(target);
// }

// AnyValue Interpreter::interpret_any(const Func* target) {
// 	interpret(target);

// 	AnyValue result;
// 	result.kind       = ValueKind::NIL;
// 	result.data.asNil = 0;

// 	return result;
// }

// void Interpreter::interpret(const Func* target) {
// 	state_.st_b.func    = target;
// 	state_.st_b.flags.trap  = false;
// 	state_.st_b.flags.error = 0;
// 	state_.st_a.pc          = target->body;
// 	do_interpret();
// }

} // namespace Ab
